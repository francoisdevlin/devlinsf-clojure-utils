<html>
<head>
	<title>Propose Changes to clojure.contrib.str-utils</title>
	<style>
	code{
		background-color:#FFFFCC;
		width:30em;
	}
	body{
		width:40em;
		margin-left:auto;		
		margin-right:auto;		
		background-color:#3333FF;
		margin-top:0px;
		margin-bottom:0px;
	}
	#page-content{
		border-color:#990000;
		border-width:0px 4px 0px 4px;
		border-style:solid;
		background-color:#FFFFFF;
		padding:5px;
		margin:0px;
	}
	</style>
</head>
<body>
	<div id="page-content">
<h1 style="text-align:center">My Proposed changes to str-utils </h1>
<h4 style="text-align:center">Sean Devlin</h4>
<h4 style="text-align:center">March 23, 2009</h4>
<p>
	I've been reviewing the str-utils package, and I'd like to propose a few changes to the library.  I've included the code at the bottom.
</p>

<h2>Use Multi-Methods</h2>
<p>
I'd like to propose re-writing the following methods to used multi-methods.  Every single method will take an input called input-string,
and a variable set of inputs called remaining-inputs.  The mutli-dispatch will make decide what to do based on the remaining inputs.
Specifically, I've used
</p>
<code>
	(class (first remaining-inputs))<br>
</code>
<p>
repeatedly.  The two most interesting classes are java.util.regex.Pattern, and clojure.lang.PersistentList.  I deliberately decided to <b>not</b>
use sequences, because I believed order was important.  One method takes a map as an input, but this is so that a tuple could be passed as an options
hash.
</p>
<br>

<h3>re-split[input-string & remaining-inputs](...)</h3>
<div class="function-description">
	The remaining inputs can be dispatched based on a regex pattern, a list of patterns, or a map.<br>

	<h4>regex pattern</h4>
	This splits a string into a list, like it does now.<br>
	<code>
	(re-split "1 2 3\n4 5 6" #"\n") => ("1 2 3" "4 5 6")<br>
	</code>
	
	<h4>list</h4>
	This splits each element either like a map or a regex.  The map operator is applied recursively to each element<br>
	<code>
	(re-split "1 2 3\n4 5 6" (list #"\n" #"\s+")) => (("1" "2" "3") ("4" "5" "6"))<br>
	</code>

	<h4>map</h4>
	This splits each element based on the inputs of the map.  It is how options are passed to the method.<br>
	
	<code>
	(re-split "1 2 3" {:pattern #"\s+" :limit 2 :marshal-fn #(java.lang.Double/parseDouble %)}) => (1.0 2.0)<br>
	</code>
	
	The :pattern and :limit options are relatively straightforward.  The :marshal-fn is mapped after the string is split.<br>

	These items can be chained together, as the following example shows<br>
	<code>
	(re-split "1 2 3\n4 5 6" (list #"\n" {:pattern #"\s+" :limit 2 :marshal-fn #(java.lang.Double/parseDouble %)})) => ((1.0 2.0) (4.0 5.0))<br>
	</code>

	In my opinion, the :marshal-fn is best used at the end of the list.  However, it could be used earlier in the list, but a exception will most likely be thrown.
</div>

<h4>re-partion[input-string & remaining-inputs]</h4>
<div class="function-description">

This methods behaves like the original re-partition method, with the remaining-inputs being able to a list or a pattern.  I don't see a need to change the behavior of this method at the moment.
</div>

<h4>re-gsub[input-string & remaining-inputs]</h4>
<div class="function-description">

This method can take a list or two atoms as the remaining inputs.<br>

Two atoms<br>
<code>
(re-gsub "1 2 3 4 5 6" #"\s" "") => "123456"<br>
</code>

A paired list<br>
<code>
(re-gsub "1 2 3 4 5 6" '((#"\s" " ) (#"\d" "D"))) => "DDDDDD"<br>
</code>

</div>

<h4>re-sub[input-string & remaining-inputs]</h4>
<div class="function-description">

Again, this method can take a list or two atoms as the remaining inputs.<br>

Two atoms<br>
<code>
	(re-sub "1 2 3 4 5 6" #"\d" "D") => "D 2 3 4 5 6"<br>
</code>

A paired list<br>
<code>
	(re-sub "1 2 3 4 5 6" '((#"\d" "D") (#"\d" "E"))) => "D E 3 4 5 6"<br>
</code>

</div>

<h2>New Parsing Helpers</h2>
<div class="function-description">
	I've created four methods, str-before, str-before-inc, str-after, str-after-inc.  They are designed to help strip off parts of string before a regex.<br>
	
	<code>
	(str-before "Clojure Is Awesome" #"\s") => "Clojure" <br>
	(str-before-inc "Clojure Is Awesome" #"\s") => "Clojure "<br>
	(str-after "Clojure Is Awesome" #"\s") => "Is Awesome"<br>
	(str-after-inc "Clojure Is Awesome" #"\s") => " Is Awesome"<br>
	</code>
	
	These methods can be used to help parse strings<br>
	<code>
	(str-before (str-after "&lt h4 ... &gt" #"&lth4") "&gt") => ;the stuff in the middle
	</code>
</div>

	<h2>
	New Inflectors
	</h2>
I've added a few inflectors that I am familiar with from Rails.  My apologies if their origin is anther language.  I'd be interested in knowing where the method originated

<h4>str-reverse</h4>
<div class="brief-function-description">
	This methods reverses a string<br>
<code>
	(str-reverse "Clojure") => "erujolC"
</code>
</div>

<h4>trim</h4>
<div class="brief-function-description">
	This is a convenience wrapper for the trim method java supplies<br>
	<code>
		(trim "  Clojure  ") => "Clojure"
	</code>
</div>

<h4>strip</h4>
<div class="brief-function-description">
	This is an alias for trim.  I accidently switch between *trim* and *strip* all the time.<br>
	<code>
		(strip "  Clojure  ") => "Clojure"
	</code>
</div>

<h4>ltrim</h4>
<div class="brief-function-description">
	This method removes the leading whitespace<br>
	<code>
		(ltrim "  Cloure  ") => "Clojure  "
	</code>
</div>

<h4>rtrim</h4>
<div class="brief-function-description">
This method removes the trailing whitespace<br>
	<code>
		(ltrim "  Cloure  ") => "  Clojure"
	</code>
</div>

<h4>downcase</h4>
<div class="brief-function-description">
	This is a convenience wrapper for the toLowerCase method java supplies<br>
	<code>
		(downcase "Clojure") => "clojure"
	</code>
</div>

<h4>upcase</h4>
<div class="brief-function-description">
	This is a convenience wrapper for the toUpperCase method java supplies<br>
	<code>
		(upcase "Clojure") => "CLOJURE"
	</code>
</div>

<h4>capitalize</h4>
<div class="brief-function-description">
	This method capitalizes a string<br>
	<code>
		(capitalize "clojure") => "Clojure"
	</code>
</div>

<h4>titleize, camelize, dasherize, underscore</h4>
<div class="brief-function-description">
These methods manipulate "sentences", producing a consistent output.  Check the unit tests for more examples<br>
	<code>
		(titleize "clojure iS Awesome") => "Clojure Is Awesome"<br>
		(camleize "clojure iS Awesome") => "clojureIsAwesome"<br>
		(dasherize "clojure iS Awesome") => "clojure-is-awesome"<br>
		(underscore "clojure iS Awesome") => "clojure_is_awesome"<br>
	</code>
</div>

<h2>Closing thoughts</h2>
<p>
There are three more methods, str-join, chop, and chomp that were already in str-utils.  I change the implementation of the methods, but the behavior should be the same.<br>

There is a big catch with my proposed change.  The signature of re-split, re-partition, re-gsub and re-sub changes.  They will not be backwards compatible, and will break code.  However, I think the flexibility is worth it.
</p>
<h2>TO-DOs</h2>
There are a few more things I'd like to add, but that could done at a later date.  

<ul>
	<li>Add more inflectors</li>
</ul>

The following additions become pretty easy if the propsed re-gsub is included:
<ul>
	<li>Add HTML-escape function (like Rails' h method)</li>
	<li>Add Javascript-escape function (like Rails' javascript-escape method)</li>
	<li>Add SQL-escape function</li>
</ul>

<p>
Okay, that's everything I can think of for now.  I'd like to thank the Stuart Sierra, and all of the contributors to this library.  This is possible because I'm standing on their shoulders.
</p>
</div>
</body>
</html>